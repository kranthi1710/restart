Valid Anagram

My Approach using hashing:(Correct conceptually but not ideal) 
/**
 * @param {string} s
 * @param {string} t
 * @return {boolean}
 */
var isAnagram = function(s, t) {
    if(s.length!==t.length){
       return false;
    } 
   let map={};
   for(let i of s){
    map[i]=(map[i] || 0) +1;
   }
   
   for(let i of t){
       if(map.hasOwnProperty(i) && map[i]>=0){
           map[i]--;
       } 
   }
return Object.values(map).every(x=>x==0);
};


The SUBTLE ISSUE in Your Code
Your current decrement logic:
for (let i of t) {
    if (map.hasOwnProperty(i) && map[i] >= 0) {
        map[i]--;
    }
}

Problem:
If t contains a character not in s, or appears more times, your code:
âŒ Does nothing
âŒ Continues looping
âŒ Only catches it later using Object.values(map)
This is less optimal and less clean.

âŒ Example Where Logic Is Weak
s = "anagram"
t = "anagramb"

b is not in map
Loop silently ignores it
You rely on the final every(x === 0) check
ğŸ‘‰ This works accidentally, but senior interviewers donâ€™t like delayed failure.


Correct way:
/**
 * @param {string} s
 * @param {string} t
 * @return {boolean}
 */
var isAnagram = function(s, t) {
    if(s.length!==t.length){
       return false;
    } 
   let map={};
   for(let i of s){
    map[i]=(map[i] || 0) +1;
   }
   
   for(let i of t){
     if(!map[i]) return false; //fail fast
     map[i]--;   
   }
       return true;
       
};
  
Say this ğŸ‘‡

â€œI use a hash map to count characters from the first string. While traversing the second string,
I decrement counts and immediately return false if a character doesnâ€™t exist or exceeds the expected frequency. This ensures O(n) time with constant space.â€

That answer alone sounds senior-level.


