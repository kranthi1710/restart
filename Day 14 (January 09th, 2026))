// longest substring
My approach(STILL all solutions not covered)
/**
 * @param {string} s
 * @return {number}
 */
var lengthOfLongestSubstring = function(s) {
    if(s.length===1) return 1;
     if(s.length===0) return 0;
    let substr="";
    let arr=[];
    let k=0;
    for(let i of s){
    if(!substr.includes(i)){
      substr+=i;
    }
    else{
        arr.push(substr);
        substr="";
        substr+=i;
    } 
   
    }
    arr.push(substr);
   for(let i of arr){
if(k<i.length){
    k=i.length;
}
   }
  return arr.length==0? s.length : k;
};

My Approach 2: (STILL FAILING)
/**
 * @param {string} s
 * @return {number}
 */
var lengthOfLongestSubstring = function(s) {
    let leftIdx=0;
    let max_sum=0;
    let current_sum=0;
    let map={};
    for(let i=0;i<s.length;i++){
        if(!map.hasOwnProperty(s[i])){
           map[s[i]]=i;
        } else{
          
          current_sum=i-map[s[i]];
          if(current_sum>max_sum){
              max_sum=current_sum;
          }
          map[s[i]]=i;
          i=leftIdx++;
        
        }
        
       }
        
return max_sum;
};

lengthOfLongestSubstring("bbbb")
----------------------------------------------------------------------------------------------------------
WHY ABOVE APPRACHES DIDN'T WORKED:
Your current code shows effort, but it still breaks core sliding window rules.
I‚Äôll improve it step by step and end with a fully correct LeetCode-safe solution.

1Ô∏è‚É£ Why Your Current Code Still Fails
‚ùå 1. You are modifying the loop index again
i = leftIdx++;

üö´ This will break iteration and cause missed characters / infinite loops.

üìå Rule:
Never modify i inside a for loop in sliding window problems.

‚ùå 2. current_sum logic is incorrect
current_sum = i - map[s[i]];

This assumes the window always starts at map[s[i]] + 1, which is not true.

‚ùå 3. leftIdx is not used correctly

You increment leftIdx, but you never use it to restrict the window properly.

‚ùå 4. Edge cases fail

Example:

"bbbb"

Expected: 1
Your output: 0 ‚ùå

üß† Minimal Change, Maximum Fix (Your Style Preserved)

Instead of resetting i, we move leftIdx safely forward.

üß† Key Fixes Explained (Very Important)
‚úî Instead of this ‚ùå
i = leftIdx++;

We do this ‚úÖ
left = map[char] + 1;

This ensures:
Left pointer never moves backward
Window remains valid
All characters processed once
-----------------------------------------------------------------------------------------------------------
Correct Approach:

/**
 * @param {string} s
 * @return {number}
 */
var lengthOfLongestSubstring = function(s) {
      let map={};
let left=0;
let maxLen=0;
//Increment the right pointer--Fast pointer
for(let right=0;right<s.length;right++){
    //Increment the left pointer - slow pointer
   //Here we are checking if char inside map does have some value instead of undefined and index value of char in map must be greater than left value(i.e, char must be within the current window).
   // Note: left pointer does not move backward.
    if(map[s[right]]!==undefined && map[s[right]]>=left){
         left=map[s[right]]+1;
    }
    
    //put the char:latestIndexOfChar in the map based on the right pointer increment.
    map[s[right]]=right;
     console.log(right,"and",s[right], "and", map[s[right]],"ad left-",left);
    //To check the count of characters in the string or array
       // map[s[right]]= (map[s[right]] ||0)+1;
       
       // check for the maximum window size
       maxLen=Math.max(maxLen,right-left+1);
}
return maxLen;
};
