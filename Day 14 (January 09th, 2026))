// longest substring
My approach(STILL all solutions not covered)
/**
 * @param {string} s
 * @return {number}
 */
var lengthOfLongestSubstring = function(s) {
    if(s.length===1) return 1;
     if(s.length===0) return 0;
    let substr="";
    let arr=[];
    let k=0;
    for(let i of s){
    if(!substr.includes(i)){
      substr+=i;
    }
    else{
        arr.push(substr);
        substr="";
        substr+=i;
    } 
   
    }
    arr.push(substr);
   for(let i of arr){
if(k<i.length){
    k=i.length;
}
   }
  return arr.length==0? s.length : k;
};

My Approach 2: (STILL FAILING)
/**
 * @param {string} s
 * @return {number}
 */
var lengthOfLongestSubstring = function(s) {
    let leftIdx=0;
    let max_sum=0;
    let current_sum=0;
    let map={};
    for(let i=0;i<s.length;i++){
        if(!map.hasOwnProperty(s[i])){
           map[s[i]]=i;
        } else{
          
          current_sum=i-map[s[i]];
          if(current_sum>max_sum){
              max_sum=current_sum;
          }
          map[s[i]]=i;
          i=leftIdx++;
        
        }
        
       }
        
return max_sum;
};

lengthOfLongestSubstring("bbbb")
----------------------------------------------------------------------------------------------------------
WHY ABOVE APPRACHES DIDN'T WORKED:
Your current code shows effort, but it still breaks core sliding window rules.
Iâ€™ll improve it step by step and end with a fully correct LeetCode-safe solution.

1ï¸âƒ£ Why Your Current Code Still Fails
âŒ 1. You are modifying the loop index again
i = leftIdx++;

ğŸš« This will break iteration and cause missed characters / infinite loops.

ğŸ“Œ Rule:
Never modify i inside a for loop in sliding window problems.

âŒ 2. current_sum logic is incorrect
current_sum = i - map[s[i]];

This assumes the window always starts at map[s[i]] + 1, which is not true.

âŒ 3. leftIdx is not used correctly

You increment leftIdx, but you never use it to restrict the window properly.

âŒ 4. Edge cases fail

Example:

"bbbb"

Expected: 1
Your output: 0 âŒ

ğŸ§  Minimal Change, Maximum Fix (Your Style Preserved)

Instead of resetting i, we move leftIdx safely forward.

ğŸ§  Key Fixes Explained (Very Important)
âœ” Instead of this âŒ
i = leftIdx++;

We do this âœ…
left = map[char] + 1;

This ensures:
Left pointer never moves backward
Window remains valid
All characters processed once
-----------------------------------------------------------------------------------------------------------
Correct Approach:

/**
 * @param {string} s
 * @return {number}
 */
var lengthOfLongestSubstring = function(s) {
      let map={};
let left=0;
let maxLen=0;
//Increment the right pointer--Fast pointer
for(let right=0;right<s.length;right++){
    //Increment the left pointer - slow pointer
   //Here we are checking if char inside map does have some value instead of undefined and index value of char in map must be greater than left value(i.e, char must be within the current window).
   // Note: left pointer does not move backward.
    if(map[s[right]]!==undefined && map[s[right]]>=left){
         left=map[s[right]]+1;
    }
    
    //put the char:latestIndexOfChar in the map based on the right pointer increment.
    map[s[right]]=right;
     console.log(right,"and",s[right], "and", map[s[right]],"ad left-",left);
    //To check the count of characters in the string or array
       // map[s[right]]= (map[s[right]] ||0)+1;
       
       // check for the maximum window size
       maxLen=Math.max(maxLen,right-left+1);
}
return maxLen;
};

Interview Explanation (Say This)

â€œI used a sliding window with a map storing last seen indices.
When a duplicate appears inside the window, I move the left pointer forward.â€

This explanation is Microsoft-grade.

Complexity:
Time: O(n)---â€œEach character is visited at most twiceâ€”once by the right pointer and once by the left pointerâ€”so the time complexity is O(n).
Each character is visited at most twiceâ€”once by the right pointer and once by the left pointerâ€”so the time complexity is O(n).â€
Map operations
map[s[right]]
map[s[right]] = right
Object access in JS is O(1) average time


Space: O(n)----Space Complexity Breakdown
Data Structure--->	Size
Map---->	O(n)
Variables---->	O(1)

ğŸ‘‰ Total Space = O(n)

ğŸ¤ Interview One-Liner (Memorize This)
â€œIn the worst case, the map stores all unique characters, so the space complexity is O(n).
