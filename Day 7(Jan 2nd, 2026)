user.name        // dot â†’ static keys
user["location"] // bracket â†’ dynamic keys
Say this ðŸ‘‡ in interviews:

â€œI use bracket notation when the key is dynamic or comes from a variable.â€

const user = { name: "Kranthi", role: "Frontend", exp: 7 };

user["location"]="hyd"
delete user.role
user.exp=8

for(let key in user){
    console.log(key,user[key])
}

Object.keys(user).forEach((key)=>console.log(key,user[key]))



---------------------------------------------------------------------------------------4

MY APPROACH:
var firstUniqChar = function(s) {
     let map={}
    for(let ch of s){
     map[ch]=(map[ch] || 0) +1
    }
    const fil=Object.keys(map).filter(key=>map[key]===1);
    return s.split("").indexOf(fil[0])
};

OPTIMIZED APPROACH(TWO PASS APPROACH)
var firstUniqChar = function(s) {
     let map={}
    for(let ch of s){
     map[ch]=(map[ch] || 0) +1
    }
   for(let i=0;i<s.length;i++){
    if(map[s[i]]===1){
        return i;
    }
   }

   return -1;
};

How to Explain This in Interview (Say This)

â€œIâ€™m using a two-pass approach.
First, I count character frequencies using a hash map.
Then I traverse the string again to find the first character with frequency one, ensuring order is preserved.â€

This explanation = strong signal.

If Interviewer Asks: â€œWhy not Object.keys?â€

Answer:

â€œBecause the problem depends on string order, and traversing the string again guarantees correctness.â€
