THIS keyword in Javascript:
const user = {
    name: "Kranthi", 
    greet(){ 
    console.log(this.name); 
    } 
}; 
user.greet(); // Kranthi
const greetFn = user.greet; 
greetFn(); //undefined
-----------------------------------------------
const greetFn = user.greet;
greetFn();
What actually happened?

You did this:
const greetFn = function() {
  console.log(this.name);
};

Now you call:
greetFn();

There is NO object before the dot.

So JS asks:

â€œWho is calling me?â€

Answer:

â€œNobody.â€

So:

this = undefined   // in strict mode


Then:
this.name â†’ undefined
âš ï¸ This is called context loss.

How to fix this:
1. Use of bind
const greetFn = user.greet.bind(user);
greetFn();

2. USe Arrow functions
const greetFn =()=> user.greet(); 
greetFn();

Say this ðŸ‘‡ confidently:

â€œIn JavaScript, this is determined by how a function is called, not where itâ€™s defined.
When a method is assigned to a variable and called independently, it loses its object context, so this becomes undefined in strict mode.â€

This sentence = senior-level clarity.

Tricky Example:
const obj = {
  name: "A",
  greet() {
    setTimeout(function () {
      console.log(this.name);
    }, 0);
  }
};

obj.greet(); // undefined

Say this ðŸ‘‡

â€œAlthough greet is called as a method, the function inside setTimeout is a regular function invoked later without an object context. Therefore, this defaults to undefined in strict mode.â€

How to make it work:
1. Use bind:
const obj = {
  name: "A",
  greet() {
    setTimeout(function () {
      console.log(this.name);
    }.bind(obj), 0);
  }
};
Regular functions get their this from how theyâ€™re called; arrow functions get this from where theyâ€™re written.

2. Use Arrow function
const obj = {
  name: "A",
  greet() {
    setTimeout( () => {
      console.log(this.name);
    }, 0);
  }
};
Reason:
Arrow functions do not have their own this
They capture this from greet
Here: this === obj







-------------------------------------------------------------------------------------------------------------------------------------------

TWO SUM:
MY Approach - Time complexity-O(n2), space complexity-O(1)
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
var twoSum = function(nums, target) {
    for(let i=0;i<nums.length;i++){
        for(let j=i+1;j<nums.length;j++){
        if(nums[i]+nums[j]===target){
            return [i,j]
        }
        }
    }
};

OPTIMIZED Approach:(HASH MAP)
var twoSum = function(nums, target) {
   let map={};

   // put all the elements in the map by giving indexes
   for(let i=0;i<nums.length;i++){
    map[nums[i]]=i;
   }
   // search for remaining sum present in the map and return the indexes
   for(let i=0;i<nums.length;i++){
    // check the difference of target and current ELement and find pairToELement
       let remElement=target-nums[i];
       // check if pairToELement must present in map and pairToELement index must not to equal to current index
       if(map[remElement]!==undefined && map[remElement]!==i){
          return [i,map[remElement]]
       }
   }
};



