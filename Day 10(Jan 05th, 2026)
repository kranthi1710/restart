//Event loop
Order of execution:
Call stack
Web APIs
Microtask queue (Promises)
Macrotask queue (setTimeout)

Predict the Output:

console.log("start");
setTimeout(() => {
  console.log("timeout");
}, 0);
Promise.resolve().then(() => {
  console.log("promise");
});
console.log("end");

Output:
start
end
promise
timeout

Explaination:
1. Synchronous code (Call Stack)
console.log("start");
console.log("end");

These run immediately
They go directly on the call stack

2. Promise (.then) â†’ Microtask Queue
Promise.resolve().then(() => {
  console.log("promise");
});

Promises are placed in the microtask queue
Microtasks run after the call stack is empty
Microtasks have higher priority than macrotasks

3.setTimeout â†’ Macrotask Queue
setTimeout(() => {
  console.log("timeout");
}, 0);


Goes to Web APIs
Then to macrotask queue
Runs only after:
Call stack is empty
Microtask queue is fully drained

Interview Explaination : 
â€œJavaScript executes synchronous code first, then drains the microtask queue (Promises), and finally executes macrotasks like setTimeout, regardless of the delay.


/**
 * @param {string} s
 * @return {boolean}
 */
var isValid = function(s) {
let stack=new Stack();
for(let ch of s){
    stack.push(ch);
}

for(let i=0;i stack){
    let removedEle=stack.pop();
    console.log(removedEle)
}

};

Correct solution:
var isValid = function(s) {
  const stack = [];

  for (let ch of s) {
    if (ch === '(' || ch === '{' || ch === '[') {
      stack.push(ch);
    } else {
      if (stack.length === 0) return false;

      const last = stack.pop();

      if (
        (ch === ')' && last !== '(') ||
        (ch === '}' && last !== '{') ||
        (ch === ']' && last !== '[')
      ) {
        return false;
      }
    }
  }

  return stack.length === 0;
};
ğŸ¤ Interview Explanation (Say This)
â€œI used a stack because brackets must close in reverse order.
I push opening brackets, and for each closing bracket I verify it matches the top of the stack.â€



âœ… Why "[({})]" is true
Letâ€™s quickly walk through it using stack logic (this is what interviewers want to hear):

Step-by-step:
[ â†’ opening â†’ push

( â†’ opening â†’ push

{ â†’ opening â†’ push

} â†’ closing â†’ matches { â†’ pop

) â†’ closing â†’ matches ( â†’ pop

] â†’ closing â†’ matches [ â†’ pop

ğŸ‘‰ Stack is empty at the end âœ…

ğŸ¯ Polished Interview Explanation (Use This)
â€œThe string is valid because every opening bracket has a matching closing bracket in the correct order. Using a stack, each closing bracket matches the most recent opening bracket, and the stack is empty at the end.â€

This explanation shows:

Pattern recognition

Correct data structure

Clear reasoning

